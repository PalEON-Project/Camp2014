#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{/accounts/gen/vis/paciorek/latex/paciorek-asa,times,graphics}
%\input{~paciorek/latex/paciorekMacros}
%\renewcommand{\baselinestretch}{1.5}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Camp PalEON R Module
\end_layout

\begin_layout Standard
In this module, we'll introduce R by way of working with some pollen data.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Basic workthrough with STEPPS pollen data (pull from Owen document, my rintro,
 data, rprog material) [see my R homework and homework for 503]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Reading in data
\end_layout

\begin_layout Standard
We can read in data using the 
\family typewriter
read.table()
\family default
 function, of which 
\family typewriter
read.csv()
\family default
 is a variant for reading in comma-delimited (CSV) files.
 
\family typewriter
getwd()
\family default
 and 
\family typewriter
setwd()
\family default
 help us navigate the computer's directory structure.
 
\family typewriter
read.fwf()
\family default
 will read fixed-width format files.
\end_layout

\begin_layout Chunk
<<reading files>>=
\end_layout

\begin_layout Chunk
getwd()
\end_layout

\begin_layout Chunk
setwd('~/Desktop/camp2012')
\end_layout

\begin_layout Chunk
pol <- read.csv('data/newEngl/modPol.csv', header = TRUE)
\end_layout

\begin_layout Chunk
ponds <- read.csv('data/newEngl/pondInfo.csv') 
\end_layout

\begin_layout Chunk
help(read.csv) 
\end_layout

\begin_layout Chunk
help(read.table) 
\end_layout

\begin_layout Chunk
names(pol) 
\end_layout

\begin_layout Chunk
head(pol) 
\end_layout

\begin_layout Chunk
class(pol)
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Section
Interlude: operating at the command line
\end_layout

\begin_layout Standard
In R, as in Linux/UNIX, there are a number of tools that enhance your efficiency
:
\end_layout

\begin_layout Enumerate
The up and down arrows recall previous entries.
\end_layout

\begin_layout Enumerate
Hitting <
\family typewriter
tab
\family default
> attempts to complete the function or object name.
\end_layout

\begin_layout Enumerate
<
\family typewriter
Ctrl-k
\family default
> kills the remainder of the line from the cursor forward.
\end_layout

\begin_layout Enumerate
<
\family typewriter
Ctrl-a
\family default
> goes to the beginning of the line (<
\family typewriter
Ctrl-e
\family default
> often goes to the end but apparently not in RStudio).
\end_layout

\begin_layout Standard
More generally, typing commands and saving your operations in text files
 (aka scripts), rather than point-and-click operations, allows you to reproduce
 your work, easily redo it and modify it, and share it with others.
\end_layout

\begin_layout Section
R objects
\end_layout

\begin_layout Standard
Everything in R is stored as an object, each of which has a class that describes
 what the object contains and standard functions that operate on objects
 in the class.
 The basic classes are 
\end_layout

\begin_layout Itemize

\emph on
character
\emph default
 vectors: these are sets of character values (i.e., strings).
 Examples of character values are: 
\emph on

\begin_inset Quotes eld
\end_inset

Sam
\begin_inset Quotes erd
\end_inset


\emph default
, 
\emph on

\begin_inset Quotes eld
\end_inset

0923
\begin_inset Quotes erd
\end_inset


\emph default
, 
\emph on

\begin_inset Quotes eld
\end_inset

Sam9
\begin_inset Quotes erd
\end_inset


\emph default
, 
\emph on

\begin_inset Quotes eld
\end_inset

Sam is
\begin_inset Quotes erd
\end_inset


\emph default
, 
\emph on

\begin_inset Quotes eld
\end_inset

Sam
\backslash
t9
\begin_inset Quotes erd
\end_inset


\emph default
, 
\emph on

\begin_inset Quotes eld
\end_inset

Sam's the man.
\backslash
nNo doubt.
\backslash
n
\begin_inset Quotes erd
\end_inset


\emph default
.
 Each of these is a character vector of length 1.
\end_layout

\begin_layout Itemize

\emph on
numeric
\emph default
 vectors (i.e., double precision real numbers)
\end_layout

\begin_layout Itemize

\emph on
integer
\emph default
 vectors
\end_layout

\begin_layout Itemize

\emph on
logical
\emph default
 (T/F) vectors
\end_layout

\begin_layout Itemize

\emph on
lists
\emph default
: vectors of arbitrary objects
\end_layout

\begin_layout Itemize

\emph on
factors
\emph default
: vector-like objects of categorical variables with a pre-defined set of
 labels
\end_layout

\begin_layout Itemize

\emph on
functions
\end_layout

\begin_layout Standard
More complicated objects:
\end_layout

\begin_layout Itemize
Data frames can be thought of as a list of vectors of the same length, where
 the vectors may have different types.
 
\end_layout

\begin_layout Itemize
Matrices are different from data frames in that all the elements are of
 a single type.
 Furthermore, matrices and arrays (which allow dimensions of 1, 2, 3, ....)
 can be thought of as vectors with information on dimensions (layout).
 If you pass a matrix into a function expecting a vector, it will just treat
 it as a vector (of concatenated columns).
\end_layout

\begin_layout Standard
We can figure out what objects exist, as well as how much memory they take
 up, and we can remove them.
 
\end_layout

\begin_layout Chunk
<<objects>>=
\end_layout

\begin_layout Chunk
class(pol) 
\end_layout

\begin_layout Chunk
x <- c(7.3, 5, 11) 
\end_layout

\begin_layout Chunk
class(x) 
\end_layout

\begin_layout Chunk
is.data.frame(x) 
\end_layout

\begin_layout Chunk
class(pol$sitename) 
\end_layout

\begin_layout Chunk
pol$sitename 
\end_layout

\begin_layout Chunk
as.character(pol$sitename) 
\end_layout

\begin_layout Chunk
class(pol$SPRUCE) 
\end_layout

\begin_layout Chunk
object.size(x) 
\end_layout

\begin_layout Chunk
x <- rnorm(10000000) 
\end_layout

\begin_layout Chunk
object.size(x) 
\end_layout

\begin_layout Chunk
print(object.size(x), units = "Mb")  
\end_layout

\begin_layout Chunk
# that code is a bit opaque and I'm lazy, so let's write our own function:
 
\end_layout

\begin_layout Chunk
size <- function(x){   
\end_layout

\begin_layout Chunk
  print(object.size(x), units = "Mb") 
\end_layout

\begin_layout Chunk
} 
\end_layout

\begin_layout Chunk
size(x) 
\end_layout

\begin_layout Chunk
ls() 
\end_layout

\begin_layout Chunk
rm(x) 
\end_layout

\begin_layout Chunk
ls() 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Section
Dataframe manipulation (and some plotting)
\end_layout

\begin_layout Standard
Let's demonstrate how we can manipulate data sets.
 First, let's get some information about our two datasets and merge them
 together.
\end_layout

\begin_layout Chunk
<<dataframeInfo, out.width=4in>>=
\end_layout

\begin_layout Chunk
names(pol) 
\end_layout

\begin_layout Chunk
class(names(pol)) 
\end_layout

\begin_layout Chunk
names(pol) <- tolower(names(pol)) 
\end_layout

\begin_layout Chunk
names(ponds) <- tolower(names(ponds)) 
\end_layout

\begin_layout Chunk
cor(pol$oak, pol$spruce) 
\end_layout

\begin_layout Chunk
dim(pol) 
\end_layout

\begin_layout Chunk
taxaCols <- 3:12
\end_layout

\begin_layout Chunk
pol$total <- rowSums(pol[ , taxaCols]) 
\end_layout

\begin_layout Chunk
pol2 <- pol 
\end_layout

\begin_layout Chunk
pol2[ , taxaCols] <- pol2[ , taxaCols] / pol2$total # careful here: I know
 that R will divide each numerator column the denominator column
\end_layout

\begin_layout Chunk
head(pol2) 
\end_layout

\begin_layout Chunk
full <- merge(ponds, pol2, by.x = "site", by.y = "sitename", all.x = FALSE,
 all.y = TRUE) 
\end_layout

\begin_layout Chunk
head(full) 
\end_layout

\begin_layout Chunk
summary(full) 
\end_layout

\begin_layout Chunk
taxaCols <- 9:18
\end_layout

\begin_layout Chunk
cor(full[ , taxaCols]) 
\end_layout

\begin_layout Chunk
require(fields, quietly = TRUE)
\end_layout

\begin_layout Chunk
image.plot(1:10, 1:10, cor(full[ , taxaCols])) # I should change the z-scale
 and the color scheme
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Now let's make some basic plots.
\end_layout

\begin_layout Chunk
<<initialPlots, out.width=4in>>=
\end_layout

\begin_layout Chunk
require(maps)
\end_layout

\begin_layout Chunk
plot(full$lon, full$lat, xlim = c(-73.5, -70), ylim = c(41.3,43.5), col = 'red',
 pch = 16) 
\end_layout

\begin_layout Chunk
map('state', add = TRUE) 
\end_layout

\begin_layout Chunk
par(mfrow=c(3,4)) 
\end_layout

\begin_layout Chunk
for(i in taxaCols){   
\end_layout

\begin_layout Chunk
  hist(full[ , i], main = names(full)[i], xlab = "proportion") 
\end_layout

\begin_layout Chunk
} 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: make a single plot that shows side-by-side boxplots of the proportions
 for each species.
 Find out what input formats the boxplot() function can handle.
 Manipulate the arguments to make your figure presentable.
\end_layout

\begin_layout Subsection*
More on indexing and subsetting
\end_layout

\begin_layout Standard
Now let's see some different ways to select subsets and use indexing.
 Often there are multiple ways to do things in R.
 Some are more efficient than others, which only really becomes an issue
 when working with large objects.
\end_layout

\begin_layout Chunk
<<subsetting, out.width=4in>>=
\end_layout

\begin_layout Chunk
sub <- full[1:5, ] 
\end_layout

\begin_layout Chunk
full$lon < (-72.5) 
\end_layout

\begin_layout Chunk
west <- full[full$lon < -72.5, ] 
\end_layout

\begin_layout Chunk
full[full$lon < -72.5, c("oak", "pine")]
\end_layout

\begin_layout Chunk
indices <- which(full$lon < -72.5)
\end_layout

\begin_layout Chunk
indices
\end_layout

\begin_layout Chunk
full[indices, c(15,16)]
\end_layout

\begin_layout Chunk
west2 <- subset(full, lon < -72.5, select = c("oak", "pine"))
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: extract the even rows of the full dataset.
 Consider the 
\family typewriter
rep()
\family default
 and 
\family typewriter
seq()
\family default
 functions.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
R does not provide a built-in function for sorting data frames.
 
\end_layout

\begin_layout Chunk
<<sorting, out.width=4in>>=
\end_layout

\begin_layout Chunk
full <- full[order(full$lat, full$lon), ]
\end_layout

\begin_layout Chunk
head(full)[ , 1:8]
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
That's a bit frustrating but easily fixable once we talk more about writing
 functions.
\end_layout

\begin_layout Section
Vectorized operations and the apply function
\end_layout

\begin_layout Standard
Many R functions operate on vectors without having to loop over the indices,
 and in fact vectorized operations are generally much faster than using
 a loop.
\end_layout

\begin_layout Chunk
<<vectorized operations, out.width=4in>>=
\end_layout

\begin_layout Chunk
log(full$oak)
\end_layout

\begin_layout Chunk
full$coldSpp <- full$beech + full$hemlock + full$spruce 
\end_layout

\begin_layout Chunk
full$west <- full$lon < -72.5 
\end_layout

\begin_layout Chunk
full$north <- full$lat > 42.5 
\end_layout

\begin_layout Chunk
full$north <- FALSE # example of recyling 
\end_layout

\begin_layout Chunk
full$north[full$lat > 42.5] <- TRUE  
\end_layout

\begin_layout Chunk
full$nw <- full$west & full$north 
\end_layout

\begin_layout Chunk
round(full$lat, digits = 1) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
Useful command
\family typewriter
s
\family default
 are 
\family typewriter
with()
\family default
 and 
\family typewriter
within()
\family default
, which allows you to avoid a bunch of typing.
 The basic idea is to do a bunch of stuff all within a certain context.
\end_layout

\begin_layout Chunk
<<with>>=
\end_layout

\begin_layout Chunk
full <- within(full, warmSpp <- oak + hemlock)
\end_layout

\begin_layout Chunk
full$warmSpp[1:8]
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: What's the difference between 
\family typewriter
with()
\family default
 and 
\family typewriter
within()
\family default
?
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
R has a feature called recycling by which it will fill in additional entries
 in vectors, matrices, data frames:
\end_layout

\begin_layout Chunk
<<recycling, out.width=4in>>=
\end_layout

\begin_layout Chunk
mat <- matrix(1:2, nrow = 4, ncol = 4) # what do you think will happen?
 
\end_layout

\begin_layout Chunk
mat <- matrix(1:3, nrow = 4, ncol = 4) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
One useful type of data structure in R is a list.
 A list is a vector of potentially unrelated items.
 Lists are commonly used as the output from functions.
\end_layout

\begin_layout Chunk
<<lists, out.width=4in>>=
\end_layout

\begin_layout Chunk
myList <- list(a = 7, b = c(8, 9, 11), d = "wtfit?", e = list(first = 7,
 second = 8)) 
\end_layout

\begin_layout Chunk
myList$b 
\end_layout

\begin_layout Chunk
myList[[2]] 
\end_layout

\begin_layout Chunk
myList$e$first
\end_layout

\begin_layout Chunk
is.list(full)
\end_layout

\begin_layout Chunk
myModel = lm(spruce ~ lat, data = full) 
\end_layout

\begin_layout Chunk
is.list(myModel) 
\end_layout

\begin_layout Chunk
names(myModel) 
\end_layout

\begin_layout Chunk
myModel$coefficients 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
We can use the apply function to 
\begin_inset Quotes eld
\end_inset

lapply
\begin_inset Quotes erd
\end_inset

 an arbitrary function to each element of the list.
 This is often faster (and is easier to write) than using a loop.
\end_layout

\begin_layout Chunk
<<apply, out.width=4in>>=
\end_layout

\begin_layout Chunk
myList = list(1:3, 4:8, 101, 111:150) 
\end_layout

\begin_layout Chunk
lapply(myList, max) # vs.
 
\end_layout

\begin_layout Chunk
out = rep(NA, length(myList)) 
\end_layout

\begin_layout Chunk
for(i in 1:length(myList))   
\end_layout

\begin_layout Chunk
   out[i] <- max(myList[[i]]) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: how can I find the median abundance of each species across all the ponds?
 
\end_layout

\begin_layout Section
Functions
\end_layout

\begin_layout Standard
We've already seen a bit of functions: we wrote our own little function
 and we've used lots of functions from the core R software and additional
 packages.
\end_layout

\begin_layout Standard
Functions allow one to modularize their code and are at the core of good
 programming.
 
\end_layout

\begin_layout Standard

\series bold
Warning
\series default
: This next bit is a bit convoluted and involved.
 It was intended to illustrate the process of writing functions in R.
 You're probably best off skipping it.
\end_layout

\begin_layout Standard
Let's consider a function I wrote for plotting compositional data on a map.
 I knew I wanted to make pie charts and put them on a map in the right locations.
 I also knew that R had a function for making pie charts.
\end_layout

\begin_layout Chunk
<<pie, out.width=4in>>=
\end_layout

\begin_layout Chunk
help(pie)
\end_layout

\begin_layout Chunk
pie(full[1, taxaCols]) 
\end_layout

\begin_layout Chunk
pie(full[1, taxaCols] + 1e-9) 
\end_layout

\begin_layout Chunk
pie(full[1, taxaCols] + .1) 
\end_layout

\begin_layout Chunk
class(full[1, taxaCols]) 
\end_layout

\begin_layout Chunk
class(c(full[1, taxaCols])) 
\end_layout

\begin_layout Chunk
class(unlist(full[1, taxaCols])) 
\end_layout

\begin_layout Chunk
vals <- unlist(full[1, taxaCols]) 
\end_layout

\begin_layout Chunk
pie(vals) 
\end_layout

\begin_layout Chunk
pie(vals, col = rainbow(length(vals))) 
\end_layout

\begin_layout Chunk
help(polygon) 
\end_layout

\begin_layout Chunk
pie(vals, col = rainbow(length(vals)), border = "NA", main = paste(full$sitename
[1], 'Pond'), cex.main = 3) 
\end_layout

\begin_layout Chunk
pie 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
So I decided to modify the pie function and call it many times from within
 a function that takes care of creating the map.
\end_layout

\begin_layout Chunk
<<pieMap, out.width=4in>>=
\end_layout

\begin_layout Chunk
pieMap <- function(proportions, centers, xlim = c(629000-6000, 809000+6000),
 ylim = c(4621000-6000, 4801000+6000), radius = NULL, scale = 1, xlab =
 'x', ylab = 'y', ...){
\end_layout

\begin_layout Chunk
# plots multiple pie composition charts as a map
\end_layout

\begin_layout Chunk
	centers <- as.matrix(centers)
\end_layout

\begin_layout Chunk
	proportions <- as.matrix(proportions)
\end_layout

\begin_layout Chunk
	if(is.null(xlim)){
\end_layout

\begin_layout Chunk
		rg <- range(centers[,1])
\end_layout

\begin_layout Chunk
		df <- (scale-1) * diff(range(centers[,1]))
\end_layout

\begin_layout Chunk
		xlim <- c(rg[1]-df, rg[2]+df)
\end_layout

\begin_layout Chunk
	}
\end_layout

\begin_layout Chunk
	if(is.null(ylim)){
\end_layout

\begin_layout Chunk
		rg <- range(centers[ ,2])
\end_layout

\begin_layout Chunk
		df <- (scale-1) * diff(range(centers[,2]))
\end_layout

\begin_layout Chunk
		ylim <- c(rg[1]-df, rg[2]+df)
\end_layout

\begin_layout Chunk
	}
\end_layout

\begin_layout Chunk
	plot(centers, type = 'n',xlim = xlim, ylim = ylim, xlab = xlab, ylab =
 ylab,...)
\end_layout

\begin_layout Chunk
	n <- length(centers[,1])
\end_layout

\begin_layout Chunk
	if(is.null(radius))
\end_layout

\begin_layout Chunk
		radius <- .025 * diff(range(centers[,1]))
\end_layout

\begin_layout Chunk
	minVal <- min(proportions)
\end_layout

\begin_layout Chunk
	if(minVal < 0)
\end_layout

\begin_layout Chunk
		stop("Some proportions are less than zero.")
\end_layout

\begin_layout Chunk
	if(length(radius) == 1)
\end_layout

\begin_layout Chunk
		radius = rep(radius,n)
\end_layout

\begin_layout Chunk
	for(i in 1:n){
\end_layout

\begin_layout Chunk
		if(sum(proportions[i,]) > 0){
\end_layout

\begin_layout Chunk
			minVal <- min(proportions[i,])
\end_layout

\begin_layout Chunk
			if(minVal == 0){
\end_layout

\begin_layout Chunk
				warning("Some proportions are zero; proceeding with jittering.")
\end_layout

\begin_layout Chunk
				eps <- 1e-10 * max(proportions[i,])
\end_layout

\begin_layout Chunk
				proportions[i,] <- proportions[i,] + eps
\end_layout

\begin_layout Chunk
			}
\end_layout

\begin_layout Chunk
			pieAdd(as.vector(proportions[i,]), as.vector(centers[i,]), radius = radius[i]
 ,...)
\end_layout

\begin_layout Chunk
		} else{
\end_layout

\begin_layout Chunk
			points(centers[i,], pch = 'X')
\end_layout

\begin_layout Chunk
		}
\end_layout

\begin_layout Chunk
	}
\end_layout

\begin_layout Chunk
	map('state', add = TRUE)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
pieAdd <- function (x, center, labels = names(x), edges = 200, radius =
 0.8, density = NULL, angle = 45, col = NULL, border = NULL, lty = NULL,
 ...) # modified from the pie() function in R
\end_layout

\begin_layout Chunk
{
\end_layout

\begin_layout Chunk
	if (!is.numeric(x) || any(is.na(x) | x <= 0)) 
\end_layout

\begin_layout Chunk
		stop("pie: `x' values must be positive.")
\end_layout

\begin_layout Chunk
	if (is.null(labels)) 
\end_layout

\begin_layout Chunk
		labels <- rep("",length(x))
\end_layout

\begin_layout Chunk
	x <- c(0, cumsum(x)/sum(x))
\end_layout

\begin_layout Chunk
	dx <- diff(x)
\end_layout

\begin_layout Chunk
	pin <- par("pin")
\end_layout

\begin_layout Chunk
	nx <- length(dx)
\end_layout

\begin_layout Chunk
	if (is.null(col)) 
\end_layout

\begin_layout Chunk
		col <- if (is.null(density)) 
\end_layout

\begin_layout Chunk
			c("white", "black","lightblue", "red","darkblue","yellow",
\end_layout

\begin_layout Chunk
				"purple","orange","lightgreen","darkgreen")
\end_layout

\begin_layout Chunk
		else par("fg")
\end_layout

\begin_layout Chunk
	col <- rep(col, length.out = nx)
\end_layout

\begin_layout Chunk
	border <- rep(border, length.out = nx)
\end_layout

\begin_layout Chunk
	lty <- rep(lty, length.out = nx)
\end_layout

\begin_layout Chunk
	angle <- rep(angle, length.out = nx)
\end_layout

\begin_layout Chunk
	density <- rep(density, length.out = nx)
\end_layout

\begin_layout Chunk
	for (i in 1:nx) {
\end_layout

\begin_layout Chunk
		n <- max(2, floor(edges * dx[i]))
\end_layout

\begin_layout Chunk
		t2p <- 2 * pi * seq(x[i], x[i + 1], length = n)
\end_layout

\begin_layout Chunk
		xc <- c(cos(t2p), 0) * radius + center[1]
\end_layout

\begin_layout Chunk
		yc <- c(sin(t2p), 0) * radius + center[2]
\end_layout

\begin_layout Chunk
		polygon(xc, yc, density = density[i], angle = angle[i], 
\end_layout

\begin_layout Chunk
		border = border[i], col = col[i], lty = lty[i],...)
\end_layout

\begin_layout Chunk
		t2p <- 2 * pi * mean(x[i + 0:1])
\end_layout

\begin_layout Chunk
		xc <- cos(t2p) * radius + center[1]
\end_layout

\begin_layout Chunk
		yc <- sin(t2p) * radius + center[2]
\end_layout

\begin_layout Chunk
		if (!is.na(lab <- labels[i]) && lab != "") {
\end_layout

\begin_layout Chunk
			lines(c(1, 1.05) * xc, c(1, 1.05) * yc)
\end_layout

\begin_layout Chunk
			text(1.1 * xc, 1.1 * yc, lab, xpd = TRUE, 
\end_layout

\begin_layout Chunk
				adj = ifelse(xc < 0, 1, 0), ...)
\end_layout

\begin_layout Chunk
		}
\end_layout

\begin_layout Chunk
	}
\end_layout

\begin_layout Chunk
	invisible(NULL)
\end_layout

\begin_layout Chunk
}
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
You can see the result of this in the Paciorek and McLachlan (2009) paper
 on modeling the New England data.
\end_layout

\begin_layout Standard

\series bold
Challenge
\series default
: write a function that sorts an arbitrary input dataset based on the user
 providing a vector of column indices on which to base the sorting order.
\end_layout

\begin_layout Section
Plotting bells and whistles
\end_layout

\begin_layout Standard
Let's take our previous plots and make them fit for the prom, or at least
 for going outside.
\end_layout

\begin_layout Chunk
<<advanced plots>>=
\end_layout

\begin_layout Chunk
pdf('treeComp.pdf', height = 4, width = 7)
\end_layout

\begin_layout Chunk
par(mfrow = c(2,5), mai = c(.25,.25,.3,.1), omi = c(.3, .3, .4, 0))
\end_layout

\begin_layout Chunk
for(i in taxaCols)
\end_layout

\begin_layout Chunk
	hist(full[ , i], xlim = c(0, 1), xlab = '', ylab = '', main = names(full)[i])
\end_layout

\begin_layout Chunk
title(ylab = 'frequency', outer = TRUE, line = 1, cex.lab = 1.5)
\end_layout

\begin_layout Chunk
title(xlab = 'proportion of pollen', outer = TRUE, line = 1, cex.lab = 1.5)
\end_layout

\begin_layout Chunk
title(main = paste('Pollen composition of ', nrow(full), ' ponds in New
 England', sep = ''),
\end_layout

\begin_layout Chunk
	outer = TRUE, line = 1, cex.main = 1.5)
\end_layout

\begin_layout Chunk
dev.off()
\end_layout

\begin_layout Chunk
help(par)
\end_layout

\begin_layout Chunk
par()$mfrow
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard

\series bold
On your own
\series default
: Take a look at the sort of graphics that R can create by invoking 
\family typewriter
demo(graphics)
\family default
, 
\family typewriter
demo(persp)
\family default
, 
\family typewriter
demo(image)
\family default
.
\end_layout

\begin_layout Section
Packages and loading data from other software
\end_layout

\begin_layout Standard
As part of preparing for the course, you've probably already downloaded
 and installed an R package from the R archive, CRAN.
 Packages provide additional functionality and are the 
\begin_inset Quotes eld
\end_inset

killer app
\begin_inset Quotes erd
\end_inset

 of R (think the App Store for Apple).
 The packages are contributed by users and R developers and vary in quality.
 They implement most statistical algorithms (and other algorithms and utilities)
 that now exist.
 So if you're about to code something, it's worth checking to see if it's
 already been done.
 And if you develop or implement a new method, consider contributing it
 to CRAN as a package.
\end_layout

\begin_layout Standard
A useful place to look for answers to questions, find out about functionality
 and pose questions is the R mailing list and its archive: http://tolstoy.newcast
le.edu.au/R/.
 If you do post, follow the guidelines and provide enough information about
 the issue for those reading the list to be able to understand the question
 and reproduce any problems.
 
\end_layout

\begin_layout Standard
One very useful package is the 
\family typewriter
foreign
\family default
 package, which contains interfaces that can read and write data formats
 for SAS, Stata, DBF, etc.
 For those who use netCDF and HDF files, there are packages that deal with
 those too (ncdf in the case of netCDF).
\end_layout

\begin_layout Chunk
<<packages>>=
\end_layout

\begin_layout Chunk
# install.packages('foreign') 
\end_layout

\begin_layout Chunk
library(foreign) 
\end_layout

\begin_layout Chunk
library(help = foreign) 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Section
Finishing up
\end_layout

\begin_layout Standard
You can save your code in text files and read it all in at once, using 
\family typewriter
source()
\family default
: e.g.,
\end_layout

\begin_layout Chunk
<<source>>=
\end_layout

\begin_layout Chunk
source('silly.R') 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
You can save some or all of your objects in an 
\begin_inset Quotes eld
\end_inset

R Dataset
\begin_inset Quotes erd
\end_inset

 and load the objects back into R.
\end_layout

\begin_layout Chunk
<<save>>=
\end_layout

\begin_layout Chunk
save(full, pol, ponds, file = 'pollenAnalData.RData') 
\end_layout

\begin_layout Chunk
save.image('pollenFullAnal.RData')
\end_layout

\begin_layout Chunk

\end_layout

\begin_layout Chunk
rm(list = ls()) 
\end_layout

\begin_layout Chunk
ls() 
\end_layout

\begin_layout Chunk
load('pollenAnalData.RData') 
\end_layout

\begin_layout Chunk
ls() 
\end_layout

\begin_layout Chunk
@
\end_layout

\begin_layout Standard
You can write out CSV and other delimited files with 
\family typewriter
write.table()
\family default
 and 
\family typewriter
write.csv()
\family default
.
\end_layout

\end_body
\end_document
